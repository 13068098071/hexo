<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ArrayList</title>
    <url>/2021/12/24/ArrayList/</url>
    <content><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/image-20211224105430699.png" alt="类图"></p>
<p><code>ArrayList</code>继承于 <code>AbstractList</code>，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p>
<ul>
<li><code>RandomAccess</code>是一个标志接口，表明实现这个这个接口的 <code>List</code>集合是支持快速随机访问的</li>
<li>实现 <code>Cloneable</code>接口并覆盖了方法<code>clone()</code>，能被克隆</li>
<li>实现了java.io.Serializable 接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">// 实际元素个数</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">//真正保存元素的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认的初始容量大小</span></span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>无参数直接初始化、指定大小初始化、指定初始数据初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、无参数直接初始化，数组大小为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、指定初始数据初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//elementData是保存数组的容器，默认为null</span></span><br><span class="line">    elementData=c.toArray();</span><br><span class="line">    <span class="comment">//如果给定的集合（c)数据有值</span></span><br><span class="line">    <span class="keyword">if</span>((size=elementData.length)!=<span class="number">0</span>)&#123;</span><br><span class="line">      	<span class="comment">//c.toArray might(incorrectly)not return Object[](see 6260652)</span></span><br><span class="line">      	<span class="comment">//如果集合元素类型不是Object类型，我们会转成Object</span></span><br><span class="line">	    <span class="keyword">if</span>(elementData.getClass()!=Object[].class)&#123;</span><br><span class="line">	        elementData=Arrays.copyOf(elementData,size,Object].class);</span><br><span class="line">	    &#125;</span><br><span class="line">  	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="comment">//给定集合（c)无值，则默认空数组</span></span><br><span class="line">    	<span class="keyword">this</span>.elementData=EMPTY_ELEMENTDATA</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//指定的初始容量大于0，将elementData初始化为指定大小的数组</span></span><br><span class="line">   <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">//否则初始化成一个空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充</p>
</blockquote>
<ul>
<li><p><code>ArrayList</code>无参构造器初始化时，默认大小是空数组，并不是大家常说的10,10是在第一次<code>add</code>的时候扩容的数组值</p>
</li>
<li><p>使用方式二进行创建对象时，如果入参容器保存的对象不是<code>Object</code>，则转换为<code>Object</code></p>
</li>
<li><p>DEFAULTCAPACITY_EMPTY_ELEMENTDATA<code>和</code>EMPTY_ELEMENTDATA是啥：它其实是定义在成员变量的两个空数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="新增和扩容实现"><a href="#新增和扩容实现" class="headerlink" title="新增和扩容实现"></a>新增和扩容实现</h4><p>新增时就是给数组中添加元素，主要分为两步走：</p>
<ul>
<li>判断是否需要扩容，如果需要扩容执行扩容操作</li>
<li>直接赋值</li>
</ul>
<blockquote>
<p>新增源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//确保数组大小是否足够，不够执行扩容，size为当前数组元素个数，判断size+1是因为后面还要size++</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//1</span></span><br><span class="line">    elementData[size++] = e;<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩容部分源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先调用calculateCapacity计算容量</span></span><br><span class="line">  	ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果当前数组还是个空数组，也就是他用过无参构造去初始化的</span></span><br><span class="line">  <span class="comment">//那么直接返回DEFAULT_CAPACITY，即10</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前容量已经大于当前数组的长度了，说明需要去扩容了</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">//oldCapacity&gt;&gt;1是把oldCapacity除以2的意思</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity=oldCapacity+(oldCapacity&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//如果扩容后的值&lt;我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">  <span class="keyword">if</span>(newCapacity-minCapacity&lt;<span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">  <span class="comment">//如果扩容后的值&gt;jvm所能分配的数组的最大值，那么就用Integer的最大值</span></span><br><span class="line">  <span class="keyword">if</span>(newCapacity-MAX_ARRAY_SIZE&gt;<span class="number">0</span>)</span><br><span class="line">    elementData=Arrays.copyOf(elementData,newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>新增时，没有对值进行校验，所以新增值可以为<code>null</code>，且没有做重复值判断，所以元素可以<code>重复</code></li>
<li>ArrayList中的数组的最大值是<code>Integer.MAX_VALUE</code>，超过这个值，<code>JVM</code>就不会给数组分配内存空间了</li>
<li>扩容是原来容量大小+容量大小的一半，简单说就是扩容后的大小是原来容量的1.5倍</li>
<li>扩容完成之后，就是简单的赋值了，赋值时并没有加锁，所以是线程<code>不安全</code>的</li>
</ul>
<h4 id="扩容的本质"><a href="#扩容的本质" class="headerlink" title="扩容的本质"></a>扩容的本质</h4><p>在<code>grow</code>方法的最后，扩容是通过<code>Arrays.copyOf(elementData,newCapacity);</code>这行代码实现的。这个方法实际上调用的方法是我们经常使用的<code>System.arraycopy</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> src 被拷贝的数组</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> srcPos 从数组那里开始</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> destPos从目标数组那个索引位置开始拷贝</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> length 拷贝的长度</span></span><br><span class="line"><span class="comment">*此方法是没有返回值的，通过dest的引用进行传值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos,Object dest, <span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个方法是一个native方法，虽然不能看到方法内部的具体实现，但通过参数也可以管中窥豹。这个方法会移动元素。所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。由于数组又是一块连续的内存空间，能够根据索引快速访问元素。<br>上面也就解释了一开始那个问题：ArrayList为什么插入慢，查询快。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><code>ArrayList</code>有多种删除方法，这里以根据值删除的方式进行说明(其他原理类似)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果要删除的值是null,删除第一个是null的值</span></span><br><span class="line">  <span class="keyword">if</span>(o==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>;index&lt;size;index++)</span><br><span class="line">      <span class="keyword">if</span>(elementData[index]==<span class="keyword">null</span>)&#123;</span><br><span class="line">        fastRemove(index)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果要删除的值不为null,找到第一个和要删除的值相等的删除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>;index&lt;size;index++)</span><br><span class="line">      <span class="comment">//这里是根据 equals来判断值相等的，相等后再根据索引位置进行删除</span></span><br><span class="line">      <span class="comment">//所以根据对象删除时，一般来说，如果你确定要删除的是某一类的业务对象，则需要重写equals</span></span><br><span class="line">      <span class="keyword">if</span>(o.equals(elementData[index])&#123;</span><br><span class="line">        fastRemove(index)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心其实是<code>fastRemove</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="comment">//记录数组的结构要发生变动了</span></span><br><span class="line">  nodCount++;</span><br><span class="line">  <span class="comment">//numMoved表示删除index位置的元素后，需要从index后移动多少个元素到前面去</span></span><br><span class="line">  <span class="comment">//减1的原因，是因为size从1开始算起，index从0开始算起</span></span><br><span class="line">  <span class="keyword">int</span> numMoved=size-index-<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(numMoved&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//从index+1位置开始被拷贝，拷贝的起始位置是index,长度是numMoved</span></span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">  <span class="comment">//数组最后一个位置赋值null,帮助GC(没有引用则自动回收了)</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们可以看出，某一个元素被删除后，为了维护数组结构，我们都会把数组后面的元素往前移动，同时释放最后一个引用，便于回收。</p>
<h3 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h3><p>在用 for 遍历集合的时候是不可以对集合进行 remove操作的，因为 remove 操作会改变集合的大小。从而容易造成结果不准确甚至数组下标越界，更严重者还会抛出 ConcurrentModificationException。</p>
<h4 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ma.collection.arraylist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 马志超</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: TestArrayList01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span> login</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/24 11:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayList01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;a&quot;</span>.equals(s))&#123;</span><br><span class="line">                list.remove(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/image-20211224112032656.png" alt="并发修改异常"></p>
<p>产生这样的异常的原因是：对集合元素进行一次修改时，对应的modCount的值就会加一，导致expectedModCount 与 modCount 不相等，然后抛出ConcurrentModificationException 。调用迭代器的删除方法，会将修改后的modCount的值赋值给expectedModCount</p>
<h4 id="迭代器的源码"><a href="#迭代器的源码" class="headerlink" title="迭代器的源码"></a>迭代器的源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cursor;       <span class="comment">// 代表下一个要访问的元素下标</span></span><br><span class="line">	<span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 代表上一个要访问的元素下标</span></span><br><span class="line">	<span class="keyword">int</span> expectedModCount = modCount; <span class="comment">//代表对 ArrayList 修改次数的期望值，初始值为 modCount</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//如果下一个元素的下标等于集合的大小 ，就证明到最后了。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cursor != size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断 expectedModCount 和 modCount 是否相等</span></span><br><span class="line">		checkForComodification();</span><br><span class="line">		<span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="comment">//看是否超过集合大小和数组长度</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">		Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="comment">//将 cursor 自增 1</span></span><br><span class="line">		cursor = i + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">		checkForComodification();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">			cursor = lastRet;</span><br><span class="line">			lastRet = -<span class="number">1</span>;</span><br><span class="line">			expectedModCount = modCount;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hasNext</p>
</blockquote>
<p>如果下一个元素的下标等于集合的大小 ，就证明到最后了</p>
<blockquote>
<p>next</p>
</blockquote>
<p>首先判断 <code>expectedModCount</code> 和 <code>modCount</code> 是否相等。然后对 <code>cursor</code> 进行判断，看是否超过集合大小和数组长度。然后将 <code>cursor</code> 赋值给 <code>lastRet</code> ，并返回下标为 lastRet 的元素。最后将 cursor 自增 1。开始时，<code>cursor = 0，lastRet = -1</code>；每调用一次 next 方法， cursor 和 lastRet 都会自增 1</p>
<blockquote>
<p>remove</p>
</blockquote>
<p>首先会判断 <code>lastRet</code> 的值是否小于 0，然后在检查 <code>expectedModCount</code> 和 <code>modCount</code> 是否相等。接下来是关键，直接调用 ArrayList 的 <code>remove</code> 方法删除下标为 <code>lastRet</code> 的元素。然后将 <code>lastRet</code> 赋值给 cursor ，将 <code>lastRet</code> 重新赋值为 -1，并将 <code>modCount</code> 重新赋值给 <code>expectedModCount</code></p>
<blockquote>
<p>异常解决</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String value = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;a&quot;</span>.equals(value)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用 iterator.remove() 即可。因为在该方法中增加了 expectedModCount = modCount 操作</p>
<blockquote>
<p>弊端</p>
</blockquote>
<ul>
<li>只能进行remove操作，add、clear 等 Itr 中没有</li>
<li>调用 remove 之前必须先调用 next。因为 remove 开始就对 lastRet 做了校验。而 lastRet 初始化时为 -1</li>
<li>next 之后只可以调用一次 remove。因为 remove 会将 lastRet 重新初始化为 -1</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>ArrayList 底层基于数组实现容量大小动态可变。</li>
<li> 扩容机制为首先扩容为原始容量的 1.5 倍。如果1.5倍太小的话，则将我们所需的容量大小赋值给 newCapacity，如果1.5倍太大或者我们需要的容量太大，那就直接拿 <code>newCapacity = (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE</code> 来扩容。 扩容之后是通过数组的拷贝来确保元素的准确性的，所以尽可能减少扩容操作。 </li>
<li>ArrayList 的最大存储能力：Integer.MAX_VALUE。 </li>
<li>size 为集合中存储的元素的个数。</li>
<li>elementData.length 为数组长度，表示最多可以存储多少个元素。 </li>
<li>如果需要边遍历边 remove ，必须使用 iterator。且 remove 之前必须先 next，next 之后只能用一次 remove。</li>
</ul>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2021/12/24/HashMap/</url>
    <content><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p> 在<code>JDK1.7</code>中HashMap的数据结构是<code>数组 + 链表</code> , 而在<code>JDK1.8</code>中则演化成了<code>数组 + 链表 + 红黑树</code>的结构 , 这也是1.8中最大的更新 , 下面我们来探究一下为何要演化为<code>数组 + 链表 + 红黑树</code>这样的数据结构</p>
<p>我们知道在1.7中当产生了<code>hash碰撞</code>时便会将当前<code>Entry</code>变成链表 , 单向链表查找除了<code>head</code>节点外的时间复杂度都是<code>O(n)</code> , 如果频繁的发生了<code>hash碰撞</code>每次查找元素都是非常耗费时间的 , 所以为了避免这一现象1.8中引入了红黑树</p>
<p>红黑树的插入、查找的时间复杂度都是<code>O(log n)</code> , 假如你的红黑树里面有256个数据 , 此时只需要8次就能找到目标数据 , 即使是65536个数据也只需要16次即可 , 效率相比链表而言提升的非常大</p>
<p>HashMap转为红黑树后存储的数据结构图</p>
<p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/image-20211224152017394.png" alt="1.8HashMap存储"></p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认初始化table数组容量16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">  			</span><br><span class="line"><span class="comment">//table最大容量1073741824</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认加载因子, 即当现有数组长度达到容量的75%时会进行扩容操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//1.8新增 当链表的长度 &gt;=8 - 1 时会转换为红黑树, 关于为什么要定义为8的详细解读在下面↓</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//1.8新增 当红黑树的长度 &lt;=6 时会转换为链表, 关于为什么红黑树 → 链表的阈值是6的详细解读在下面↓</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//1.8新增 红黑树的最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//定义一个类型为Node&lt;K,V&gt;的table数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//table数组的长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际的扩容的阈值 threshold = 容量 * 加载因子</span></span><br><span class="line"><span class="comment">//在构造器中会被初始化为DEFAULT_INITIAL_CAPACITY的值16</span></span><br><span class="line"><span class="comment">//在第一次存储数据时会在inflateTable()方法中再次赋值threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际的加载因子, 在构造器中进行初始化</span></span><br><span class="line"><span class="comment">//如果创建HashMap时没有指定loadFactor的大小则会初始化为DEFAULT_INITIAL_CAPACITY的值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap更改的次数</span></span><br><span class="line"><span class="comment">//用来作为并发下判断是否有其它线程修改了该HashMap,抛出ConcurrentModificationException</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在初始化时指定初始长度及加载因子的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在初始化时指定初始长度的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//这里调用的其实还是上面的构造器</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//什么也不指定的构造器 , 这里不像1.7中还是去调用了有参构造器 , 具体原因下面会有分析</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h5 id="TREEIFY-THRESHOLD"><a href="#TREEIFY-THRESHOLD" class="headerlink" title="TREEIFY_THRESHOLD"></a><code>TREEIFY_THRESHOLD</code></h5></blockquote>
<p>这个参数是链表转换成红黑树的阈值，TREEIFY_THRESHOLD = 8</p>
<ol>
<li><p>为什么不在一开始就使用红黑树来替代链表</p>
<p>相同数据量下红黑树(TreeNode)占用的空间是链表(Node)的俩倍 , 考虑到时间和空间的权衡 , 只有当链表的长度达到阈值时才会将其转成红黑树</p>
</li>
<li><p>为什么链表 → 红黑树的阈值是8呢?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* In usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">* rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">* nodes in bins follows a Poisson distribution</span><br><span class="line">* (http:<span class="comment">//en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line">* parameter of about <span class="number">0.5</span> on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing</span><br><span class="line">* threshold of <span class="number">0.75</span>, although with a large variance because of</span><br><span class="line">* resizing granularity. Ignoring variance, the expected</span><br><span class="line">* <span class="function">occurrences of list size k <span class="title">are</span> <span class="params">(exp(-<span class="number">0.5</span>)</span> * <span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span> /</span></span><br><span class="line"><span class="function">* <span class="title">factorial</span><span class="params">(k)</span>). The first values are:</span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">* 0:    0.60653066</span></span><br><span class="line"><span class="function">* 1:    0.30326533</span></span><br><span class="line"><span class="function">* 2:    0.07581633</span></span><br><span class="line"><span class="function">* 3:    0.01263606</span></span><br><span class="line"><span class="function">* 4:    0.00157952</span></span><br><span class="line"><span class="function">* 5:    0.00015795</span></span><br><span class="line"><span class="function">* 6:    0.00001316</span></span><br><span class="line"><span class="function">* 7:    0.00000094</span></span><br><span class="line"><span class="function">* 8:    0.00000006</span></span><br><span class="line"><span class="function">* more: less than 1 in ten million</span></span><br></pre></td></tr></table></figure>

<p>HashMap的作者认为在理想的情况下随机hashCode算法下所有节点的分布频率会遵循<a href="http://en.wikipedia.org/wiki/Poisson_distribution">泊松分布(Poisson distribution)</a> , 上面也列举了链表长度达到8的概率是0.00000006,也就是说我们几乎不可能会使用到红黑树 , 所以作者使用8作为一个分水岭</p>
</li>
</ol>
<blockquote>
<p>UNTREEIFY_THRESHOLD</p>
</blockquote>
<p>为何链表 → 红黑树的阈值，UNTREEIFY_THRESHOLD = 6</p>
<ol>
<li><p>为何链表 → 红黑树的阈值是6</p>
<p>假设UNTREEIFY_THRESHOLD的 = 7 , 当我们有频繁的添加和删除操作时 , hash碰撞产生的节点数量 一旦在7附件徘徊就会造成红黑树和链表的频繁转换 , 此时我们大多数的性能就都耗费在了链表 → 红黑树和红黑树 → 链表` ,这样反而就得不偿失了 , 所以作者将长度为7作为一个缓存地段从而选取了6作为红黑树 → 链表的阈值</p>
</li>
</ol>
<blockquote>
<p>loadFactor</p>
</blockquote>
<ul>
<li>加载因子并不是越大越好的 , 虽然加载因子越大就意味着HashMap的实际容量越大 , 扩容的次数越少 , 但是因为实际存储的数据大了 , 俩个相同容量的HashMap加载因子越大的那个读取的速度更慢 , 所以我们需要根据自己的实际使用情况来进行判断 , 是要存储更多的数据呢 , 还是要更快的读取速度</li>
<li>加载因子是会影响到扩容的次数的 , 如果加载因子太小的话HashMap会频繁的进行扩容 , 导致在存储的时候性能下降</li>
<li>如果我们在创建HashMap时就已经知道了要存储的数据量 , 那么我们完全可以通过实际存储数量 ÷ 0.75来计算出我们初始化的HashMap容量 , 这样可以避免HashMap再进行扩容操作 , 提升代码效率</li>
</ul>
<blockquote>
<p>modCount</p>
</blockquote>
<p>HashMap不是线程安全的 , 也就是说你在操作的同时可能会有其它的线程也在操作该map,那样会造成脏数据 , 所以为了避免这种情况发生HashMap、ArrayList等使用了fail-fast策略 , 用modCount来记录修改集合修改次数</p>
<p>我们在边迭代边删除集合元素时会碰到一个异常ConcurrentModificationException , 原因是不管你使用entrySet()方法也好 , keySet()方法也好 , 其实在for循环的时候还是会使用该集合内置的Iterator迭代器中的nextEntry()方法 , 如果你没有使用Iterator内置的remove()方法 , 那么迭代器内部的记录更改次数的值便不会被同步 , 当你下一次循环时调用nextEntry()方法便会抛出异常</p>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/image-20211224153116502.png" alt="HashMap的put"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key) ,  key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//关于onlyIfAbsent,evict的讲解在下面↓</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; </span><br><span class="line">     Node&lt;K,V&gt; p; </span><br><span class="line">     <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">// 判断数组是否为空 , 为空则调用resize()方法进行初始化,resize()方法源码在下面↓</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line"> 	  <span class="comment">// 如果当前数组索引位置的元素为null则直接创建新的节点并存到该索引位置的数组中</span></span><br><span class="line"> 	  <span class="comment">// 和JDK1.7的对比</span></span><br><span class="line"> 	  <span class="comment">//1. 其实这里的(n - 1) &amp; hash就是JDK1.7中的indexFor()方法体中的(length - 1) &amp; h,只不过在1.8中做了简化处理</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          <span class="comment">//2. tab[i] = newNode(hash, key, value, null);在JDK1.7中时在createEntry()方法中完成创建Entry的 , 在1.8中该方法也被删除了</span></span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">			</span><br><span class="line">	  <span class="comment">// 走到这个else代码块中说明当前key已经在数组中存在了 || 发生了hash碰撞</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="comment">// 判断当前key在数组中是否存在, 存在则不进行存储操作</span></span><br><span class="line">          <span class="comment">// 有朋友好奇这里的p是在哪里初始化的, 其实在上一个if里面就被初始化了</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// 判断当前节点类型是否是红黑树节点</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              <span class="comment">// 将key、value存储到红黑树节点中 , 如果key已经存在 , 则返回之前的节点 , 源码解析在下面↓</span></span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// 代码进入到这个else代码块就说明发生了hash碰撞</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 该代码块中的e的初始化会有俩种情况</span></span><br><span class="line">              <span class="comment">// ① e是最后一个节点的next元素,e == null</span></span><br><span class="line">              <span class="comment">// ② e是和key相同的那个node</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                  <span class="comment">// 判断当前节点是否是链表的最后一个节</span></span><br><span class="line">                  <span class="comment">// ①</span></span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">// 直接将当前要存储的key、value存储到上一个节点的next元素中</span></span><br><span class="line">                      <span class="comment">// 在JDK1.7中的会先将之前存储的节点取出来, 然后将之前的节点作为新节点的next元素存储到数组中</span></span><br><span class="line">                      <span class="comment">// 而在JDK1.8中会直接将新的节点放到之前存储节点的next元素中</span></span><br><span class="line">                      <span class="comment">// 也就是说JDK1.7中的链表插入顺序是从头部开始插入, 而在1.8中时从尾部开始插入</span></span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                      <span class="comment">// 因为这个循环是迭代链表的, 所以binCount代表着链表的长度, 如果链表长度超过阈值则会转换为红黑树</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          <span class="comment">// 转换红黑树的源码解析在下面↓</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                </span><br><span class="line">                  <span class="comment">// 当前节点不是最后一个节点, 判断当前节点的key与要存储的key是否相同</span></span><br><span class="line">                  <span class="comment">// ②</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">  		  <span class="comment">// e在只有当前key已经存在时才会完成初始化], 这里是统一处理, 返回key之前对应的value, 并判断是否要替换value,默认是替换</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              V oldValue = e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              <span class="comment">// 这里是个空方法体</span></span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++modCount;</span><br><span class="line"> 	  <span class="comment">// 在JDK1.7中扩容操作是在存储数据之前发生的</span></span><br><span class="line"> 	  <span class="comment">// 在JDK1.8中扩容操作是在存储数据之后发生的</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">	  <span class="comment">// 这里是个空方法体</span></span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先会判断哈希表Node&lt;k,v&gt;[] table是否为空或者null，是则进行resize()方法进行扩容，否则进入下一个阶段；</li>
<li>根据key计算的hash值，hash值&amp;（length-1）得到数组所在的存储位置table[i]，如果存储位置没有元素存放，则直接创建一个新Node；</li>
<li>如果存储位置有元素存放，则接下来会判断该位置元素的hash值和key值是否和当前操作元素一致，如果一致，说明是修改value操作，直接进行覆盖；</li>
<li>当前存储位置有元素，又不和当前操作元素一致，说明发生了hash冲突，在这里他又有两种方式，分别是链表和红黑树，区别就在于他们的头结点，如果头结点是treeNode，则说明此位置结构是红黑树方式插入；</li>
<li>如果不是红黑树，则说明是单链表，将新增节点插入至链表的最后位置，但是这里还有一个判断点，判断当前链表长度是否大于等于8.如果是则将链表转化为红黑树，遍历过程如果key存在，则直接覆盖；</li>
<li>最后就是判断当前存储键值对的数量，如果大于阈值值，则扩容；</li>
</ul>
<blockquote>
<p>onlyIfAbsent</p>
</blockquote>
<p>onlyIfAbsent：如果为true，则不更改现有值 , 也就是说不会用新的value来替换旧的value</p>
<blockquote>
<h5 id="hash"><a href="#hash" class="headerlink" title="hash()"></a><code>hash()</code></h5></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//高16位和低16位进行异或运算，增散列程度，减少hash碰撞发生的概率</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>为什么HashMap的容量一定要是2的非零次方幂而且还要进行<code>hash &amp; (length - 1)</code>的操作</strong></p>
</blockquote>
<p>如果容量是2的次方 , 那么length - 1得到的二进制的除了补位外都是1,根据&amp;运算符的规则 , 0&amp;0=0; 0&amp;1=0; 1&amp;1=1;那么也就意味着不论hash的值是什么 , 只要length - 1的二进制码是这样规律的 , 那么就可以保证hash的值只有和length - 1的同位参与了运算 , 例如二进制码A(10101011)&amp;B(00001111)的结果就是C(00001011) , C的结果只会受到B二进制码后四位的影响 , 因为b的补位都是0 , 也就是说h &amp; (length - 1)得到的索引不会大于length,也就不会越界</p>
<h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">   <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">   <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">   <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 进入到这个if代码块中说明此时table数组已经完成过初始化</span></span><br><span class="line">   <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 判断当前容量是否已达到最大值</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span> oldTab;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="comment">// 将新数组的容量设置为旧容量的2倍</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">           <span class="comment">// 这一步的操作等同于 oldThr * 2</span></span><br><span class="line">           newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 进入到这个代码块说明在创建HashMap时使用的有参构造器</span></span><br><span class="line">   <span class="comment">// 在翻阅代码后我们发现threshold的值会在有参构造器中被初始化 , 此时被初始化了就会使用指定的容量来完成table数组的初始化</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">       newCap = oldThr;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 进入到这个else代码块中说明数组还未完成初始化 , 进行初始化操作</span></span><br><span class="line">   <span class="keyword">else</span> &#123;               </span><br><span class="line">       newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">       newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line"> 		</span><br><span class="line">   <span class="comment">// 只有调用有参构造器才让newThr == 0,至于为什么不放到上面的else if中 , 可能是为以后扩展做铺垫吧</span></span><br><span class="line">   <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">       newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                 (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">   &#125;</span><br><span class="line">   threshold = newThr;</span><br><span class="line">   <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot; , &quot;unchecked&quot;&#125;)</span></span><br><span class="line">   <span class="comment">// 初始化新数组</span></span><br><span class="line">   Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">   table = newTab;</span><br><span class="line">   <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">           Node&lt;K,V&gt; e;</span><br><span class="line">           <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">// 如果当前不是链表则会直接将当前元素放到新数组中旧元素所在索引位置</span></span><br><span class="line">               <span class="comment">// 至于为什么 , 在下面会有详细讲解↓</span></span><br><span class="line">               <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                   newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">             	</span><br><span class="line">               <span class="comment">// 如果当前元素是红黑树的节点</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">             </span><br><span class="line">               <span class="comment">// 进入这个代码块中说明当前数组元素是链表</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// loHead和loTail存储的是转移数据后仍然存储在当前索引位置的元素</span></span><br><span class="line">                   Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">// hiHead和hiTail存储的是转移数据后存储到[j + oldCap]索引位置的元素</span></span><br><span class="line">                   <span class="comment">// 这里看不懂没事 , 接着往下看就明白了</span></span><br><span class="line">                   Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K,V&gt; next;</span><br><span class="line">                 e = <span class="number">1</span> e.next = <span class="number">2</span> e.next.next = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       <span class="comment">// 为了方便讲明白这个循环里面的源码,我们来举个例子,假设此时链表有3个元素a,b,c</span></span><br><span class="line">                       <span class="comment">// 第一次循环进入到① | ②</span></span><br><span class="line">                       <span class="comment">// tail元素肯定为null,所以会将当前e赋值给head元素,并且为tail赋值,以便下次循环</span></span><br><span class="line">                       <span class="comment">// 此时head元素会含有e的链表关系即next元素指针,此时就是e=a  head=a  tail=a</span></span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">// 第二次循环进入① | ②</span></span><br><span class="line">                       <span class="comment">// 还是会通过第一次进入时的索引判断 , 所以此时tail元素不会为null,</span></span><br><span class="line">                       <span class="comment">// 此时就是 e=b  head=a  head.next=b  tail=b  tail.next=b</span></span><br><span class="line">                       <span class="comment">// 因为在第一次进入的时候head和tail是同时指向e的</span></span><br><span class="line">                       <span class="comment">// 所以此时tail.next=b也就意味着head.next=b,所以才会先在else代码块中完成tail.next的初始化</span></span><br><span class="line">                       <span class="comment">// 再完成tail的初始化</span></span><br><span class="line">                       </span><br><span class="line">                   	   <span class="comment">// 第三次循环进入① | ② 就是 e=c  head=a  tail=c  tail.next=c  head.next.next=c</span></span><br><span class="line">                   	   <span class="comment">// 以此类推....</span></span><br><span class="line">                       next = e.next;</span><br><span class="line">                       <span class="comment">// 这里会根据(e.hash &amp; oldCap) == 0来将链表划分为俩部分 , 一部分仍然存储在旧链表的索引位置 , 另一部分存储到新数组的[j + oldCap]索引位置</span></span><br><span class="line">                       <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">// ①</span></span><br><span class="line">                           <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                               loHead = e;</span><br><span class="line">                           <span class="comment">// ②</span></span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                               loTail.next = e;</span><br><span class="line">                           loTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">// ①</span></span><br><span class="line">                           <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                               hiHead = e;</span><br><span class="line">                           <span class="comment">// ②</span></span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                               hiTail.next = e;</span><br><span class="line">                           hiTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                   <span class="comment">// 将loHead存储到新数组的旧索引位置</span></span><br><span class="line">                   <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j] = loHead;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 将hiHead存储到新数组的[j + oldCap]索引位置</span></span><br><span class="line">                   <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j + oldCap] = hiHead;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/image-20211224154248251.png" alt="HashMap的get"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key) ,  key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 计算索引位置并判断当前索引位置是否存在元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前元素是否与要取得值相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 判断当前元素是否有next元素</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前元素是否是红黑树节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 寻找红黑树中与要取值相等的节点</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 迭代链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7和1-8对比"><a href="#1-7和1-8对比" class="headerlink" title="1.7和1.8对比"></a>1.7和1.8对比</h3><table>
<thead>
<tr>
<th></th>
<th>1.7</th>
<th>1.8</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>节点</td>
<td>Entry</td>
<td>Node TreeNode</td>
</tr>
<tr>
<td>Hash算法</td>
<td>较为复杂</td>
<td>异或hash右移16位</td>
</tr>
<tr>
<td>对Null的处理</td>
<td>单独写一个putForNull()方法处理</td>
<td>作为以一个Hash值为0的普通节点处理</td>
</tr>
<tr>
<td>初始化</td>
<td>赋值给一个空数组，put时初始化</td>
<td>没有赋值，懒加载，put时初始化</td>
</tr>
<tr>
<td>扩容</td>
<td>插入前扩容</td>
<td>插入后，初始化，树化时扩容</td>
</tr>
<tr>
<td>节点插入</td>
<td>头插法</td>
<td>尾插法</td>
</tr>
</tbody></table>
<p>参看文档：<a href="https://blog.csdn.net/weixin_44141495/article/details/108402128">https://blog.csdn.net/weixin_44141495/article/details/108402128</a></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><blockquote>
<p><strong>什么时候扩容</strong></p>
</blockquote>
<ol>
<li>当前容量超过阈值</li>
<li>当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树</li>
</ol>
<blockquote>
<p><strong>什么时候链表转化为红黑树</strong></p>
</blockquote>
<p>当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树</p>
<blockquote>
<p><strong>为什么HashMap的初始容量是16，扩容时一定要是2的n次方</strong></p>
</blockquote>
<p>index = HashCode（key） &amp; (length-1)</p>
<p>以值为“book”的Key来演示：</p>
<ol>
<li>计算book的hashcode，结果为十进制的3029737，二进制的101110001110101110 1001。</li>
<li>假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111。</li>
<li>把以上两个结果做与运算，101110001110101110 1001 &amp; 1111 = 1001，十进制是9，所以 index=9。</li>
</ol>
<p><strong>Hash算法最终得到的index结果，完全取决于Key的Hashcode值的最后几位</strong></p>
<p>假设HashMap的长度是10，重复刚才的运算步骤：</p>
<p><img src="https://img-blog.csdnimg.cn/20190109165033757.jpg" alt="img"></p>
<p>单独看这个结果，表面上并没有问题。我们再来尝试一个新的HashCode 101110001110101110 <strong>1011</strong> ：</p>
<p><img src="https://img-blog.csdnimg.cn/20190109165144678.jpg" alt="img"></p>
<p>虽然HashCode的倒数第二第三位从0变成了1，但是运算的结果都是1001。也就是说，当HashMap长度为10的时候，有些index结果的出现几率会更大，而有些index结果永远不会出现.这样，显然不符合Hash算法均匀分布的原则。</p>
<p>反观长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p>
<p><strong>总结</strong></p>
<ul>
<li>取模运算效率很低，为了实现高效的Hash算法，HashMap的采用了位运算的方式</li>
<li>为了Hash算法的结果就是均匀的</li>
</ul>
<blockquote>
<p>深入理解HashMap线程不安全的体现</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653192000&amp;idx=1&amp;sn=118cee6d1c67e7b8e4f762af3e61643e&amp;chksm=8c990d9abbee848c739aeaf25893ae4382eca90642f65fc9b8eb76d58d6e7adebe65da03f80d&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653192000&amp;idx=1&amp;sn=118cee6d1c67e7b8e4f762af3e61643e&amp;chksm=8c990d9abbee848c739aeaf25893ae4382eca90642f65fc9b8eb76d58d6e7adebe65da03f80d&amp;scene=21#wechat_redirect</a></p>
<blockquote>
<p>如何处理hash冲突</p>
</blockquote>
<ul>
<li><p>开发定址法：既然当前位置容不下冲突的元素了，那就再找一个空的位置存储 Hash 冲突的值（当前 index 冲突了，那么将冲突的元素放在 index+1)。</p>
</li>
<li><p>再散列法：换一个 Hash 算法再计算一个 hash 值，如果不冲突了就存储值（例如第一个算法是名字的首字母的 Hash 值，如果冲突了，计算名字的第二个字母的 Hash 值，如果冲突解决了则将值放入数组中）。</p>
</li>
<li><p>链地址法：每个数组中都存有一个单链表，发生 Hash 冲突时，只是将冲突的 value 当作新节点插入到链表（HashMap 解决冲突的办法）。</p>
</li>
<li><p>公共溢出区法：将冲突的 value 都存到另外一个顺序表中，查找时如果当前表没有对应值，则去溢出区进行顺序查找。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList</title>
    <url>/2021/12/24/LinkedList/</url>
    <content><![CDATA[<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><blockquote>
<p>什么是链表</p>
</blockquote>
<p>链表是由一系列非连续的节点组成的存储结构，简单分下类的话，链表又分为单向链表和双向链表，而单向/双向链表又可以分为循环链表和非循环链表</p>
<blockquote>
<p>单向链表</p>
</blockquote>
<p>单向链表就是通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null。</p>
<p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/193331_JljJ_2927759.png" alt="单向列表"></p>
<blockquote>
<p>单向循环链表</p>
</blockquote>
<p>单向循环链表和单向列表的不同是，最后一个节点的next不是指向null，而是指向head节点，形成一个“环”。</p>
<p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/193412_xGR9_2927759.png" alt="单向循环链表"></p>
<blockquote>
<p>双向链表</p>
</blockquote>
<p>双向链表是包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre指向null，最后一个节点的tail指向null。</p>
<p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/193440_9dt2_2927759.png" alt="双向链表"></p>
<blockquote>
<p>双向循环链表</p>
</blockquote>
<p>双向循环链表和双向链表的不同在于，第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”。<strong>而LinkedList就是基于双向循环链表设计的。</strong></p>
<p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/193526_9m6M_2927759.png" alt="双向循环链表"></p>
<p>LinkedList底层是基于双向链表，链表在内存中不是连续的，而是通过引用来关联所有的元素，所以链表的优点在于添加和删除元素比较快，因为只是移动指针，并且不需要判断是否需要扩容，缺点是查询和遍历效率比较低。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/image-20211224141813601.png" alt="类图"> LinkedList底层是基于双向链表，链表在内存中不是连续的，而是通过引用来关联所有的元素，所以链表的优点在于添加和删除元素比较快，因为只是移动指针，并且不需要判断是否需要扩容，缺点是查询和遍历效率比较低。</p>
<ul>
<li>LinkedList是基于双向循环链表实现的，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用</li>
<li>实现了所有可选的List操作并且允许存储任何元素，包括Null</li>
<li>LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆</li>
<li>LinkedList是非线程安全的，只在单线程下适合使用</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="成员变量的构造方法"><a href="#成员变量的构造方法" class="headerlink" title="成员变量的构造方法"></a>成员变量的构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前存储的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 首节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 末节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *传入集合参数的构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();<span class="comment">//调用当前类的构造函数</span></span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h4><blockquote>
<p>add</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取当前链表的最后一个节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个以当前最后一个节点为之前节点的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空表，首次插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;<span class="comment">//不是首次插入，则最后一个节点的后置节点地址赋值给新节点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>addAll</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *在链表的尾端追加指定集合的所有元素，按指定的迭代器的集合顺序返回，在这个操作执行总是如果指定的集合被修改了</span></span><br><span class="line"><span class="comment"> *，那么该行为操作将提示未定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 检查index是否越界，index=size+1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将集合参数转化为数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;<span class="comment">//要插入的集合长度</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义pred和succ两个Node对象，用于标识要插入元素的前置节点和后置节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里为什么要写if..else？</span></span><br><span class="line"><span class="comment">     * 因为该方法不一定是从上层方法addAll(size, c)过来的，还有可能是直接调用了addAll(int index, Collection&lt;? extends E&gt; c)</span></span><br><span class="line"><span class="comment">     * 方法，从上层addAll(size, c)跳转过来的，size=index也就从尾部插入，但是直接调用的该方法，则从传进来的参数index这个位置（肯能是任何位置）插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;<span class="comment">//表明是从尾部插入</span></span><br><span class="line">        succ = <span class="keyword">null</span>;<span class="comment">//从尾部插入，后置节点为null</span></span><br><span class="line">        pred = last;<span class="comment">//从尾部插入，前置节点为当前LinkedList中的最后一个节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//表明不是从尾部插入</span></span><br><span class="line">        succ = node(index);<span class="comment">//查到当前LinkedList中位置为index的节点并把它赋给要插入元素的后置节点</span></span><br><span class="line">        pred = succ.prev;<span class="comment">//把上一步得到的节点的前置节点赋值给要插入元素的后置节点</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;<span class="comment">//变量集合参数</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//说明插入之前当前链表是空链表</span></span><br><span class="line">            first = newNode;<span class="comment">//新节点是第一个节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;<span class="comment">//设置插入元素的的前置节点的后置节点为新节点</span></span><br><span class="line">        pred = newNode;<span class="comment">//更改指向后将新节点对象赋给pred作为下次循环中新插入节点的前一个对象节点，依次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//此时pred代表集合元素的插入完后的最后一个节点对象</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;<span class="comment">//结尾添加的话在添加完集合元素后将最后一个集合的节点对象pred作为last</span></span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;<span class="comment">//将集合元素的最后一个节点对象的next指针指向原index位置上的Node对象</span></span><br><span class="line">        succ.prev = pred;<span class="comment">//将原index位置上的pred指针对象指向集合的最后一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> * 返回index位置的非空节点</span></span><br><span class="line"><span class="comment"> * 折半查询 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果index小于当前元素个数的一半，则从前向后遍历查询 ，否则从后向前遍历查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面主要是两个方法：</p>
<ul>
<li>addAll(int index, Collection&lt;? extends E&gt; c)，这里面首先是判断了是否会出现索引越界的坑你，然后定义pred和succ两个Node对象，用于标识要插入元素的前置节点和后置节点，这段代码的工作原理，可以理解为一根筷子切成A,B两根,A的末尾处的节点为新插入元素的前置节点，B的开始出的节点为新插入元素的后置节点，新插入的元素集合依次放在A,B之间，然后把前置节点和后置节点连接上，就插入完成了。</li>
<li>node（int index）:这个方法的主要功能是找到index位置的Node节点，源码上利用折半查询进行优化，即使这样，遍历和查询效率还是比较差。</li>
</ul>
<h4 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h4><blockquote>
<p>根据元素移除</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *从第一个节点循环指针查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果移除的数据为Null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历找到第一个为null的节点，然后移除掉</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//遍历找到第一条不为null与参数相等的数据，然后移除掉</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">	<span class="comment">//移除的数据</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">//移除节点的后置节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">  <span class="comment">//移除节点的前置节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据索引移除</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><blockquote>
<p>get(index),getFirst(),getLast()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);<span class="comment">//检查是否越界</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;<span class="comment">//折半查询节点，然后获取该节点的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><blockquote>
<p>set</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);<span class="comment">//检查是否越界</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);<span class="comment">//折半查询索引为index的节点</span></span><br><span class="line">    E oldVal = x.item;<span class="comment">//查询index节点原来的数据值</span></span><br><span class="line">    x.item = element;<span class="comment">//将新值插入</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;<span class="comment">//返回旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>clear</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历所以的数据，置为null,方便垃圾回收</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>toArray</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有的节点，将节点中的值放入数组中</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>LinkedList的实现是基于双向循环链表的，且头结点中不存放数据。</li>
<li>在查找和删除某元素时，源码中都划分为该元素为null和不为null两种情况来处理，LinkedList中允许元素为null</li>
<li>LinkedList是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法</li>
<li>LinkedList是基于链表实现的，因此插入删除效率高，查找效率低</li>
<li>实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用</li>
</ul>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2021/12/22/Shell/</url>
    <content><![CDATA[<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1 变量"></a>1 变量</h3><h4 id="1-1-变量定义"><a href="#1-1-变量定义" class="headerlink" title="1.1 变量定义"></a>1.1 变量定义</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=mzc</span><br><span class="line">name=&#x27;mzc&#x27;</span><br><span class="line">name=&quot;mzc&quot;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-使用变量"><a href="#1-2-使用变量" class="headerlink" title="1.2 使用变量"></a>1.2 使用变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=mzc</span><br><span class="line">echo $&#123;name&#125;</span><br><span class="line">echo $&#123;name&#125;qwe</span><br></pre></td></tr></table></figure>

<h4 id="1-3-设置只读变量"><a href="#1-3-设置只读变量" class="headerlink" title="1.3 设置只读变量"></a>1.3 设置只读变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=mzc</span><br><span class="line">readonly name</span><br></pre></td></tr></table></figure>

<h4 id="1-4-删除变量"><a href="#1-4-删除变量" class="headerlink" title="1.4 删除变量"></a>1.4 删除变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=mzc</span><br><span class="line">unset name</span><br></pre></td></tr></table></figure>

<h4 id="1-5-变量类型"><a href="#1-5-变量类型" class="headerlink" title="1.5 变量类型"></a>1.5 变量类型</h4><p>全局变量（环境变量）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export name</span><br><span class="line">password=qwe</span><br><span class="line">declare -x password</span><br></pre></td></tr></table></figure>

<h4 id="1-6-字符串"><a href="#1-6-字符串" class="headerlink" title="1.6 字符串"></a>1.6 字符串</h4><p>单引号与双引号的区别：</p>
<ul>
<li>单引号中的内容会原样输出，不会执行、不会取变量；</li>
<li>双引号中的内容可以执行、可以取变量；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=mzc</span><br><span class="line">echo &#x27;hello, $name \&quot;hh\&quot;&#x27;  # 单引号字符串，输出 hello, $name \&quot;hh\&quot;</span><br><span class="line">echo &quot;hello, $name \&quot;hh\&quot;&quot;  # 双引号字符串，输出 hello, yxc &quot;hh&quot;</span><br></pre></td></tr></table></figure>

<p>获取字符串长度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=mzc</span><br><span class="line">echo $&#123;#name&#125; # 3</span><br></pre></td></tr></table></figure>

<p>提取子串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;name:0:2&#125; # 取0-2字符</span><br></pre></td></tr></table></figure>

<h3 id="2-默认变量"><a href="#2-默认变量" class="headerlink" title="2 默认变量"></a>2 默认变量</h3><h4 id="2-1-文件参数变量"><a href="#2-1-文件参数变量" class="headerlink" title="2.1 文件参数变量"></a>2.1 文件参数变量</h4><p>在执行shell脚本时，可以向脚本传递参数。$1是第一个参数，$2是第二个参数，以此类推。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">echo &quot;文件名：&quot;$0</span><br><span class="line">echo &quot;第一个参数：&quot;$1</span><br><span class="line">echo &quot;第二个参数：&quot;$2</span><br><span class="line">echo &quot;第三个参数：&quot;$3</span><br><span class="line">echo &quot;第四个参数：&quot;$4</span><br><span class="line"></span><br><span class="line">acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4</span><br><span class="line">文件名：./test.sh</span><br><span class="line">第一个参数：1</span><br><span class="line">第二个参数：2</span><br><span class="line">第三个参数：3</span><br><span class="line">第四个参数：4</span><br></pre></td></tr></table></figure>

<h4 id="2-2-其他参数"><a href="#2-2-其他参数" class="headerlink" title="2.2 其他参数"></a>2.2 其他参数</h4><p><img src="C:\Users\17561\Desktop\笔记\图片\shell命令.png"></p>
<h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3 数组"></a>3 数组</h3><p>数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。<br>数组下标从0开始。</p>
<h4 id="3-1-数组的定义"><a href="#3-1-数组的定义" class="headerlink" title="3.1 数组的定义"></a>3.1 数组的定义</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array=(1,abc,&quot;asd&quot;,qwe)</span><br><span class="line"></span><br><span class="line">array[0]=1</span><br><span class="line">array[1]=zxc</span><br></pre></td></tr></table></figure>

<h4 id="3-2-取值"><a href="#3-2-取值" class="headerlink" title="3.2 取值"></a>3.2 取值</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;array[index]&#125;</span></span><br><span class="line"></span><br><span class="line">echo array[0]</span><br><span class="line">echo array[1]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取出所有</span></span><br><span class="line">echo $&#123;array[*]&#125;</span><br><span class="line">echo $&#123;array[@]&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数组长度</span></span><br><span class="line">echo $&#123;#array[*]&#125;</span><br><span class="line">echo $&#123;#array[@]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-expr命令"><a href="#4-expr命令" class="headerlink" title="4 expr命令"></a>4 expr命令</h3><p>expr命令用户求表达式的值，格式为：expr 表达式</p>
<p>表达式说明：</p>
<ul>
<li>用空格隔开每一项</li>
<li>用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义）</li>
<li>对包含空格和其他特殊字符的字符串要用引号括起来</li>
<li>expr会在stdout中输出结果。如果为逻辑关系表达式，则结果为真，stdout为1，否则为0。</li>
<li>expr的exit code：如果为逻辑关系表达式，则结果为真，exit code为0，否则为1。</li>
</ul>
<h4 id="4-1-字符串表达式"><a href="#4-1-字符串表达式" class="headerlink" title="4.1 字符串表达式"></a>4.1 字符串表达式</h4><ul>
<li>length string 返回string长度</li>
<li>index string charset    charset中任意单个字符在string中最前面的字符位置，下标从1开始。如果在string中完全不存在charset中的字符，则返回0。</li>
<li>substr string position length    返回STRING字符串中从POSITION开始，长度最大为LENGTH的子串。如果POSITION或LENGTH为负数，0或非数值，则返回空字符串。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str=&quot;hello world!&quot;</span><br><span class="line">echo `expr length &quot;$str&quot;`  # 输出12</span><br><span class="line">echo `expr` index &quot;$str&quot; awd`  # 输出 7</span><br><span class="line">echo `expr substr &quot;$&#123;str&#125;&quot; 2 3`  # 输出 ell</span><br></pre></td></tr></table></figure>

<h4 id="4-2-数学表达式"><a href="#4-2-数学表达式" class="headerlink" title="4.2 数学表达式"></a>4.2 数学表达式</h4><p>expr支持普通的算术操作，算术表达式优先级低于字符串表达式，高于逻辑关系表达式。</p>
<ul>
<li>{+  -} 加减运算。两端参数会转换为整数，如果转换失败则报错。</li>
<li>{* / %} 乘，除，取模运算。两端参数会转换为整数，如果转换失败则报错。</li>
<li>() 可以该表优先级，但需要用反斜杠转义</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=3</span><br><span class="line">b=4</span><br><span class="line"></span><br><span class="line">echo `expr $&#123;a&#125; + $&#123;b&#125;` # 7</span><br><span class="line">echo `expr $&#123;a&#125; - $&#123;b&#125;` # -1</span><br><span class="line">echo `expr $&#123;a&#125; \* $&#123;b&#125;` # 12</span><br><span class="line">echo `expr $&#123;a&#125; / $&#123;b&#125;` # 0</span><br><span class="line">echo `expr $&#123;a&#125; % $&#123;b&#125;` # 3</span><br><span class="line">echo `expr \( $a + 1 \) \* \( $b + 1 \)` # 20</span><br></pre></td></tr></table></figure>

<h4 id="4-3-逻辑关系表达式"><a href="#4-3-逻辑关系表达式" class="headerlink" title="4.3 逻辑关系表达式"></a>4.3 逻辑关系表达式</h4><ul>
<li>| 如果第一个参数非空且非0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0。如果第一个参数是非空或非0时，不会计算第二个参数</li>
<li> &amp; 如果两个参数都非空且非0，则返回第一个参数，否则返回0。如果第一个参为0或为空，则不会计算第二个参数。</li>
<li>&lt; &lt;= = == != &gt;= &gt;  比较两端的参数，如果为true，则返回1，否则返回0。”==”是”=”的同义词。”expr”首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。</li>
<li>() 可以该表优先级，但需要用反斜杠转义</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=3</span><br><span class="line">b=4</span><br><span class="line"></span><br><span class="line">echo `expr $a \&gt; $b`  # 输出0，&gt;需要转义</span><br><span class="line">echo `expr $a &#x27;&lt;&#x27; $b`  # 输出1，也可以将特殊字符用引号引起来</span><br><span class="line">echo `expr $a &#x27;&gt;=&#x27; $b`  # 输出0</span><br><span class="line">echo `expr $a \&lt;\= $b`  # 输出1</span><br><span class="line"></span><br><span class="line">c=0</span><br><span class="line">d=5</span><br><span class="line"></span><br><span class="line">echo `expr $c \&amp; $d`  # 输出0</span><br><span class="line">echo `expr $a \&amp; $b`  # 输出3</span><br><span class="line">echo `expr $c \| $d`  # 输出5</span><br><span class="line">echo `expr $a \| $b`  # 输出3</span><br></pre></td></tr></table></figure>

<h3 id="5-read"><a href="#5-read" class="headerlink" title="5 read"></a>5 read</h3><p>read命令用于从标准输入中读取单行数据。当读到文件结束符时，exit code为1，否则为0</p>
<p>参数说明</p>
<ul>
<li>-p: 后面可以接提示信息</li>
<li>-t：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read name</span><br><span class="line">mzc</span><br><span class="line">echo $name </span><br><span class="line">mzc</span><br><span class="line"></span><br><span class="line">read -p &quot;Please input your name：&quot; -t 5 name</span><br><span class="line">Please input your name：mzc</span><br><span class="line">echo $name</span><br><span class="line">mzc</span><br></pre></td></tr></table></figure>

<h3 id="6-echo"><a href="#6-echo" class="headerlink" title="6 echo"></a>6 echo</h3><p>输出格式：echo string</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 普通字符串</span></span><br><span class="line">echo &quot;Hello World&quot;</span><br><span class="line">echo Hello World</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示变量</span></span><br><span class="line">name=mzc</span><br><span class="line">echo &quot;My name is $name&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示换行</span></span><br><span class="line">echo -e &quot;Hi\n&quot;</span><br><span class="line">echo &quot;acwing&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示不换行</span></span><br><span class="line">echo -e &quot;Hi \c&quot;</span><br><span class="line">echo acwing</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示结果定向至文件</span></span><br><span class="line">echo &quot;Hello World&quot; &gt; out.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示时间</span></span><br><span class="line">echo `date`</span><br></pre></td></tr></table></figure>

<h3 id="7-print"><a href="#7-print" class="headerlink" title="7 print"></a>7 print</h3><p>printf命令用于格式化输出，类似于C/C++中的printf函数。</p>
<p>默认不会在字符串末尾添加换行符。</p>
<p>命令格式：printf format string</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf &quot;%10d.\n&quot; 123</span><br><span class="line">printf &quot;%-10.2f.\n&quot; 123.123123</span><br><span class="line">printf &quot;My name is %s\n&quot; &quot;mzc&quot;</span><br><span class="line">printf &quot;%d + %d = %d\n&quot; 2 3 `expr 2 \* 3`</span><br><span class="line"></span><br><span class="line">       123.</span><br><span class="line">123.12    .</span><br><span class="line">My name is yxc</span><br><span class="line">2 * 3 = 6</span><br></pre></td></tr></table></figure>

<h3 id="8-test"><a href="#8-test" class="headerlink" title="8 test"></a>8 test</h3><h4 id="8-1-逻辑运算符-amp-amp-和"><a href="#8-1-逻辑运算符-amp-amp-和" class="headerlink" title="8.1 逻辑运算符&amp;&amp;和||"></a>8.1 逻辑运算符&amp;&amp;和||</h4><ul>
<li>&amp;&amp; 表示与，|| 表示或</li>
<li>二者具有短路原则：<br>expr1 &amp;&amp; expr2：当expr1为假时，直接忽略expr2<br>expr1 || expr2：当expr1为真时，直接忽略expr2</li>
<li>表达式的exit code为0，表示真；为非零，表示假。（与C/C++中的定义相反）</li>
</ul>
<h4 id="8-2-test命令"><a href="#8-2-test命令" class="headerlink" title="8.2 test命令"></a>8.2 test命令</h4><p>在命令行中输入man test，可以查看test命令的用法。</p>
<p>test命令用于判断文件类型，以及对变量做比较。</p>
<p>test命令用exit code返回结果，而不是使用stdout。0表示真，非0表示假。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test 2 -lt 3 # 为真 0</span><br><span class="line">echo $? # 输出0</span><br><span class="line"></span><br><span class="line">ls  # 列出当前目录下的所有文件</span><br><span class="line">homework  output.txt  test.sh  tmp</span><br><span class="line">test -e test.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</span><br><span class="line">exist  # test.sh 文件存在</span><br><span class="line">test -e test2.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;</span><br><span class="line">Not exist  # testh2.sh 文件不存在</span><br></pre></td></tr></table></figure>

<h4 id="8-3-文件类型判断"><a href="#8-3-文件类型判断" class="headerlink" title="8.3 文件类型判断"></a>8.3 文件类型判断</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test -e filename # 判断文件是否存在</span><br></pre></td></tr></table></figure>

<p>-e 文件是否存在</p>
<p>-f 是否为文件</p>
<p>-d 是否为目录</p>
<h4 id="8-4-文件权限判断"><a href="#8-4-文件权限判断" class="headerlink" title="8.4 文件权限判断"></a>8.4 文件权限判断</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test -r filename # 判断文件是否可读</span><br></pre></td></tr></table></figure>

<p>-r 是否可读</p>
<p>-w 是否可写</p>
<p>-x 是否可执行</p>
<p>-s 是否为非null文件</p>
<h4 id="8-5-整数间的比较"><a href="#8-5-整数间的比较" class="headerlink" title="8.5 整数间的比较"></a>8.5 整数间的比较</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test $a -eq $b # a 是否等于 b </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>等于</td>
</tr>
<tr>
<td>-ne</td>
<td>不等于</td>
</tr>
<tr>
<td>-gt</td>
<td>大于</td>
</tr>
<tr>
<td>-lt</td>
<td>小于</td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于</td>
</tr>
</tbody></table>
<h4 id="8-6-字符串比较"><a href="#8-6-字符串比较" class="headerlink" title="8.6 字符串比较"></a>8.6 字符串比较</h4><table>
<thead>
<tr>
<th>参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>test -z string</td>
<td>是否为null，为null，返回true</td>
</tr>
<tr>
<td>test -n string</td>
<td>是否为非null，非null，返回true</td>
</tr>
<tr>
<td>test str1 == str2</td>
<td>是否相等</td>
</tr>
<tr>
<td>test str1 != str2</td>
<td>是否不相等</td>
</tr>
</tbody></table>
<h4 id="8-7-多重条件判定"><a href="#8-7-多重条件判定" class="headerlink" title="8.7 多重条件判定"></a>8.7 多重条件判定</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test -r filename -a -x filename</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>代表意义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>两个条件同时成立</td>
</tr>
<tr>
<td>-o</td>
<td>两个条件至少成立一个</td>
</tr>
<tr>
<td>!</td>
<td>取反</td>
</tr>
</tbody></table>
<h4 id="8-8-判断符号"><a href="#8-8-判断符号" class="headerlink" title="8.8 判断符号[]"></a>8.8 判断符号[]</h4><p>[]与test用法几乎一模一样，更常用于if语句中。另外[[]]是[]的加强版，支持的特性更多。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ a -lt 3 ] # 为真，返回 0</span><br><span class="line">echo $? # 输出0</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">homework  output.txt  test.sh  tmp</span><br><span class="line">[ -e test.sh ] &amp;&amp; echo &quot;exit&quot; || echo &quot;not exit&quot; </span><br><span class="line">exit</span><br><span class="line">[ -e test.sh ] &amp;&amp; echo &quot;exit&quot; || echo &quot;not exit&quot; </span><br><span class="line">not exit</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>[]内的每一项都要用空格隔开</li>
<li>中括号内的变量，最好用双引号括起来</li>
<li>中括号内的常数，最好用单或双引号括起来</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=&quot;acwing yxc&quot;</span><br><span class="line">[ $name == &quot;acwing yxc&quot; ]  # 错误，等价于 [ acwing yxc == &quot;acwing yxc&quot; ]，参数太多</span><br><span class="line">[ &quot;$name&quot; == &quot;acwing yxc&quot; ]  # 正确</span><br></pre></td></tr></table></figure>

<h3 id="9-判断语句"><a href="#9-判断语句" class="headerlink" title="9 判断语句"></a>9 判断语句</h3><h4 id="9-1-单层if"><a href="#9-1-单层if" class="headerlink" title="9.1 单层if"></a>9.1 单层if</h4><p>格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if condition</span><br><span class="line">then </span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">	....</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">a=3</span><br><span class="line">b=4</span><br><span class="line">if [ $a -lt $b ] </span><br><span class="line">then </span><br><span class="line">	echo $a</span><br><span class="line">fi	</span><br></pre></td></tr></table></figure>

<h4 id="9-2-单层if-else"><a href="#9-2-单层if-else" class="headerlink" title="9.2 单层if-else"></a>9.2 单层if-else</h4><p>格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">	...</span><br><span class="line">else </span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">	...</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">a=3</span><br><span class="line">b=4</span><br><span class="line">if ! [ &quot;$a&quot; -lt &quot;$b&quot; ]</span><br><span class="line">then </span><br><span class="line">	echo $a</span><br><span class="line">else </span><br><span class="line">	echo $b</span><br><span class="line">fi	</span><br></pre></td></tr></table></figure>

<h4 id="9-3-多层if-elif-elif-else"><a href="#9-3-多层if-elif-elif-else" class="headerlink" title="9.3 多层if-elif-elif-else"></a>9.3 多层if-elif-elif-else</h4><p>格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">	...</span><br><span class="line">elif condition</span><br><span class="line">then</span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">	...</span><br><span class="line">elif condition</span><br><span class="line">then</span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">	...</span><br><span class="line">else</span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">	...</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">a=4</span><br><span class="line">if [ $a -eq 1 ]</span><br><span class="line">then </span><br><span class="line">	echo $a</span><br><span class="line">elif [ $a -eq 2 ]	</span><br><span class="line">then </span><br><span class="line">	echo $a</span><br><span class="line">elif [ $a -eq 3 ]	</span><br><span class="line">then</span><br><span class="line">	echo $a</span><br><span class="line">else </span><br><span class="line">	echo $a</span><br><span class="line">fi	</span><br></pre></td></tr></table></figure>

<h4 id="9-4-case…esac形式"><a href="#9-4-case…esac形式" class="headerlink" title="9.4 case…esac形式"></a>9.4 case…esac形式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名称 in</span><br><span class="line">	值1)</span><br><span class="line">		语句1</span><br><span class="line">		语句2</span><br><span class="line">		...</span><br><span class="line">		;;</span><br><span class="line">	值2)	</span><br><span class="line">		语句1</span><br><span class="line">		语句2</span><br><span class="line">		...</span><br><span class="line">		;;</span><br><span class="line">	*)		</span><br><span class="line">		语句1</span><br><span class="line">		语句2</span><br><span class="line">		...</span><br><span class="line">		;;</span><br><span class="line">esac		</span><br><span class="line"></span><br><span class="line">a=4</span><br><span class="line">case $a in</span><br><span class="line">	1)</span><br><span class="line">		echo $a</span><br><span class="line">		;;</span><br><span class="line">	2)</span><br><span class="line">    	echo $a</span><br><span class="line">    	;;</span><br><span class="line">    3)	</span><br><span class="line">    	echo $a</span><br><span class="line">    	;;</span><br><span class="line">    *)	</span><br><span class="line">    	echo $a</span><br><span class="line">    	;;</span><br><span class="line">esac    	</span><br></pre></td></tr></table></figure>

<h3 id="10-循环语句"><a href="#10-循环语句" class="headerlink" title="10 循环语句"></a>10 循环语句</h3><h4 id="10-1-for…in…do…done"><a href="#10-1-for…in…do…done" class="headerlink" title="10.1 for…in…do…done"></a>10.1 for…in…do…done</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in val1 val2 val3</span><br><span class="line">do</span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">	...</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出遍历元素</span></span><br><span class="line">for i in a 22 cc</span><br><span class="line">do</span><br><span class="line">	echo $i</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出当前路劲下的所有文件名</span></span><br><span class="line">for i in `ls`</span><br><span class="line">do</span><br><span class="line">	echo $i</span><br><span class="line">done </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出1-10</span></span><br><span class="line">for i in $(seq 1 10)</span><br><span class="line">do</span><br><span class="line">	echo $i</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &#123;1..10&#125; &#123;a..z&#125;</span></span><br><span class="line">for i in &#123;a..z&#125;</span><br><span class="line">do</span><br><span class="line">	echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="10-2-for-…-…-…-do…done"><a href="#10-2-for-…-…-…-do…done" class="headerlink" title="10.2 for ((…;…;…)) do…done"></a>10.2 for ((…;…;…)) do…done</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for((expression;condition;expression))</span><br><span class="line">do</span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for((i = 0; i &lt;= 10; i++))</span><br><span class="line">do</span><br><span class="line">	echo $i</span><br><span class="line">done	</span><br></pre></td></tr></table></figure>

<h4 id="10-3-until…do…done循环"><a href="#10-3-until…do…done循环" class="headerlink" title="10.3 until…do…done循环"></a>10.3 until…do…done循环</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until condition </span><br><span class="line">do</span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">	..</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">until [ &quot;$&#123;word&#125;&quot; == &quot;yes ] || [ &quot;$&#123;word&#125;&quot; == &quot;YES&quot;]</span><br><span class="line">do</span><br><span class="line">	read -p &quot;Please input yes/YES to stop this program&quot; word</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="11-函数"><a href="#11-函数" class="headerlink" title="11 函数"></a>11 函数</h3><p>bash中的函数类似于C/C++中的函数，但return的返回值与C/C++不同，返回的是exit code，取值为0-255，0表示正常结束。</p>
<p>如果想获取函数的输出结果，可以通过echo输出到stdout中，然后通过$(function_name)来获取stdout中的结果。</p>
<p>函数的return值可以通过$?来获取。</p>
<p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[function] function_name()&#123; # function可以省略</span><br><span class="line">	语句1</span><br><span class="line">	语句2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func()&#123;</span><br><span class="line">	name=mzc</span><br><span class="line">	echo &quot;Hello $name&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func</span><br><span class="line"></span><br><span class="line">func()&#123;</span><br><span class="line">	name=mzc</span><br><span class="line">	echo &quot;Hello $name&quot;</span><br><span class="line">	return 123</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output=$(func)</span><br><span class="line">ret=$?</span><br><span class="line"></span><br><span class="line">echo	&quot;output=$(output)&quot;</span><br><span class="line">echo	&quot;return=$(ret)&quot;</span><br></pre></td></tr></table></figure>

<h4 id="11-1-函数的输入参数"><a href="#11-1-函数的输入参数" class="headerlink" title="11.1 函数的输入参数"></a>11.1 函数的输入参数</h4><p>在函数内，$1表示第一个输入参数，$2表示第二个输入参数，依次类推</p>
<p>注意：$0表示文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func()&#123;</span><br><span class="line">	word=&quot;&quot;</span><br><span class="line">	while [ &quot;$word&quot; != &#x27;y&#x27; ] &amp;&amp; [ &quot;$word&quot; != &#x27;n&#x27; ]</span><br><span class="line">	do</span><br><span class="line">		read -p &quot;&quot;要进入func($1)函数吗？请输入y/n：&quot; word</span><br><span class="line">	done</span><br><span class="line">	</span><br><span class="line">	if [ &quot;word&quot; == &#x27;n&#x27; ]</span><br><span class="line">	then</span><br><span class="line">		echo 0</span><br><span class="line">		return 0</span><br><span class="line">	fi</span><br><span class="line">	</span><br><span class="line">	if [ $1 -le 0 ]</span><br><span class="line">	then </span><br><span class="line">		echo 0</span><br><span class="line">		return 0</span><br><span class="line">	fi</span><br><span class="line">	</span><br><span class="line">	sum=$(func $(expr $1 - 1))</span><br><span class="line">	echo $(expr $sum + $1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo $(func 10)</span><br></pre></td></tr></table></figure>



<h3 id="11-练习"><a href="#11-练习" class="headerlink" title="11 练习"></a>11 练习</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ***************  homework_0  *****************</span></span><br><span class="line">dir0=/home/acs/homework/lesson_1/homework_0</span><br><span class="line"></span><br><span class="line">homework 1 create 0</span><br><span class="line"></span><br><span class="line">for i in dir_a dir_b dir_c</span><br><span class="line">do</span><br><span class="line">    mkdir &quot;$&#123;dir0&#125;/$i&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ***************  homework_1  *****************</span></span><br><span class="line">dir1=/home/acs/homework/lesson_1/homework_1</span><br><span class="line"></span><br><span class="line">homework 1 create 1</span><br><span class="line"></span><br><span class="line">for i in a.txt b.txt c.txt </span><br><span class="line">do</span><br><span class="line">    cp &quot;$&#123;dir1&#125;/$&#123;i&#125;&quot; &quot;$&#123;dir1&#125;/$&#123;i&#125;.bak&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ***************  homework_2  *****************</span></span><br><span class="line">dir2=/home/acs/homework/lesson_1/homework_2</span><br><span class="line"></span><br><span class="line">homework 1 create 2</span><br><span class="line"></span><br><span class="line">for i in a b c</span><br><span class="line">do</span><br><span class="line">    mv &quot;$&#123;dir2&#125;/$&#123;i&#125;.txt&quot; &quot;$&#123;dir2&#125;/$&#123;i&#125;_new.txt&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ***************  homework_3  *****************</span></span><br><span class="line">dir3=/home/acs/homework/lesson_1/homework_3</span><br><span class="line"></span><br><span class="line">homework 1 create 3</span><br><span class="line"></span><br><span class="line">for i in a.txt b.txt c.txt</span><br><span class="line">do</span><br><span class="line">    mv &quot;$&#123;dir3&#125;/dir_a/$&#123;i&#125;&quot; &quot;$&#123;dir3&#125;/dir_b&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ***************  homework_4  *****************</span></span><br><span class="line"></span><br><span class="line">dir4=/home/acs/homework/lesson_1/homework_4</span><br><span class="line"></span><br><span class="line">homework 1 create 4</span><br><span class="line"></span><br><span class="line">rm $&#123;dir4&#125;/*</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ***************  homework_5  *****************</span></span><br><span class="line"></span><br><span class="line">dir5=/home/acs/homework/lesson_1/homework_5</span><br><span class="line">homework 1 create 5</span><br><span class="line"></span><br><span class="line">rm -rf $&#123;dir5&#125;/*</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ***************  homework_6  *****************</span></span><br><span class="line"></span><br><span class="line">dir6=/home/acs/homework/lesson_1/homework_6</span><br><span class="line"></span><br><span class="line">homework 1 create 6</span><br><span class="line"></span><br><span class="line">mkdir &quot;$&#123;dir6&#125;/dir_a&quot;</span><br><span class="line"></span><br><span class="line">mv &quot;$&#123;dir6&#125;/task.txt&quot; &quot;$&#123;dir6&#125;/dir_a/done.txt&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ***************  homework_7  *****************</span></span><br><span class="line">dir7=/home/acs/homework/lesson_1/homework_7</span><br><span class="line"></span><br><span class="line">homework 1 create 7</span><br><span class="line"></span><br><span class="line">for((i = 0; i &lt; 3; i++))</span><br><span class="line">do</span><br><span class="line">    mkdir $&#123;dir7&#125;/dir_$&#123;i&#125;</span><br><span class="line">    for j in a b c</span><br><span class="line">    do</span><br><span class="line">        cp $&#123;dir7&#125;/$&#123;j&#125;.txt $&#123;dir7&#125;/dir_$&#123;i&#125;/$&#123;j&#125;$&#123;i&#125;.txt</span><br><span class="line">    done</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ***************  homework_8  *****************</span></span><br><span class="line">dir8=/home/acs/homework/lesson_1/homework_8</span><br><span class="line"></span><br><span class="line">homework 1 create 8</span><br><span class="line">rm $&#123;dir8&#125;/dir_a/a.txt</span><br><span class="line">mv $&#123;dir8&#125;/dir_b/b.txt $&#123;dir8&#125;/dir_b/b_new.txt</span><br><span class="line">cp $&#123;dir8&#125;/dir_c/c.txt $&#123;dir8&#125;/dir_c/c.txt.bak</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ***************  homework_9  *****************</span></span><br><span class="line"></span><br><span class="line">dir9=/home/acs/homework/lesson_1/homework_9</span><br><span class="line"></span><br><span class="line">homework 1 create 9</span><br><span class="line"></span><br><span class="line">rm $&#123;dir9&#125;/*.txt</span><br><span class="line">homework 1 test</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-electric-clock</title>
    <url>/2021/12/23/hexo-electric-clock/</url>
    <content><![CDATA[<h2 id="hexo-electric-clock-电子时钟插件"><a href="#hexo-electric-clock-电子时钟插件" class="headerlink" title="hexo-electric-clock 电子时钟插件"></a>hexo-electric-clock 电子时钟插件</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://raw.githubusercontent.com/13068098071/picode/main/img/image-20211223195858557.png" alt="时钟"></p>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i hexo-electric-clock --save</span><br></pre></td></tr></table></figure>

<h3 id="在主-config配置"><a href="#在主-config配置" class="headerlink" title="在主_config配置"></a>在主_config配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">electric_clock:</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">layout:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sticky_layout</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">temple_html:</span> <span class="string">&#x27;&lt;div class=&quot;card-widget card-clock&quot;&gt;&lt;div class=&quot;card-glass&quot;&gt;&lt;div class=&quot;card-background&quot;&gt;&lt;div class=&quot;card-content&quot;&gt;&lt;div id=&quot;hexo_electric_clock&quot;&gt;&lt;img id=&quot;card-clock-loading&quot; src=&quot;https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif&quot; style=&quot;height: 120px; width: 100%;&quot; data-ll-status=&quot;loading&quot; class=&quot;entered loading&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><blockquote>
<p>enbale</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 是否开启插件</span></span><br><span class="line">enable: true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>enable_page</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 路由地址，all 代表全局开启。如 / 代表主页。</span></span><br><span class="line">enable_page: all</span><br></pre></td></tr></table></figure>

<blockquote>
<p>priority</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 插件的叠放顺序，数字越大，叠放约靠前。</span></span><br><span class="line">priority: 5 # 这里是参数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>layout</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 参数：<span class="built_in">type</span>; （class&amp;id）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数：name;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数：index；（数字）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 含义：如果说 electric_clock 是一幅画，那么这个 layout 就是指定了哪面墙来挂画</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 而在 HTML 的是世界里有两种墙分别 <span class="built_in">type</span> 为 id 和 class。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中在定义 class 的时候会出现多个 class 的情况，这时就需要使用 index，确定是哪一个。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后墙的名字即是 name;</span></span><br><span class="line"></span><br><span class="line">layout:</span><br><span class="line">    type: class</span><br><span class="line">    name: sticky_layout</span><br><span class="line">    index: 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>temple_html</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-widget card-clock&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 挂载容器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-glass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-background&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hexo_electric_clock&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">            <span class="attr">id</span>=<span class="string">&quot;card-clock-loading&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">style</span>=<span class="string">&quot;height: 120px; width: 100%;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">data-ll-status</span>=<span class="string">&quot;loading&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;entered loading&quot;</span></span></span><br><span class="line"><span class="tag">          /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>butterfly</tag>
      </tags>
  </entry>
</search>
